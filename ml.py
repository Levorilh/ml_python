from linear import *from mlp import *init_random()"""import numpy as npimport osfrom PIL import ImageIMG_SIZE = (8, 8)PATH = os.path.join("data_large/")TRAIN = os.path.join(PATH, "train")classes = os.listdir(TRAIN)print(classes)def import_images_and_assign_labels(folder, label, X, Y):    for file in os.listdir(folder):        image_path = os.path.join(folder, file)        im = Image.open(image_path)        im = im.resize((8, 8))        im = im.convert("RGB")        im_arr = np.array(im)        im_arr = np.reshape(im_arr, (8 * 8 * 3))        X.append(im_arr)        Y.append(label)def import_dataset():    X_train, y_train, X_valid, y_valid = [], [], [], []    labels = np.identity(len(os.listdir(TRAIN)))    for set_type in ["train", "valid"]:        for cl, lab in zip(classes, labels):            if set_type == "train":                X_set, y_set = X_train, y_train            else:                X_set, y_set = X_valid, y_valid            import_images_and_assign_labels(                os.path.join(PATH, set_type, cl),                lab,                X_set,                y_set            )    return (np.array(X_train) / 255.0, np.array(y_train)), \           (np.array(X_valid) / 255.0, np.array(y_valid))(X_train, y_train), (X_valid, y_valid) = import_dataset()input_dim = [len(X_train[0]), 64, 80, 8]print(input_dim)print(len(X_train))picture_test = np.random.randint(0, len(X_train))p_model, len_output_layer = create_mlp_model(input_dim)test_before = predict_mlp_model_classification(p_model, X_train[picture_test], len_output_layer)print("Before training:", test_before)train_classification_stochastic_gradient_backpropagation_mlp_model(p_model, X_train, y_train.flatten(), epochs=30000,                                                                   alpha=0.01)test_after = predict_mlp_model_classification(p_model, X_train[picture_test], len_output_layer)print("After training:", test_after)print("class index : ", np.argmax(test_after))print("class Expected :", np.argmax(y_train[picture_test]))print()print()print()picture_test = np.random.randint(0, len(X_train))test_after = predict_mlp_model_classification(p_model, X_train[picture_test], len_output_layer)print("After training:", test_after)print("class index : ", np.argmax(test_after))print("class Expected :", np.argmax(y_train[picture_test]))destroy_mlp_model(p_model)p_model = create_linear_model(1000)filename = "models/lastmodel.txt"save_linear_model(p_model, 1000, filename)try:    p_model_size, p_model2 = load_linear_model(filename)    print(p_model_size, np.ctypeslib.as_array(p_model2, (p_model_size,)))    destroy_linear_model(p_model)    destroy_linear_model(p_model2)except:    print("aie")# input_dim = [2, 3, 4]# p_model = create_linear_model(8)## filename = "models/lin/load.txt"# save_linear_model(p_model, 8, filename)## try:#     p_model2, _ = load_linear_model(filename)##     # before_save = predict_mlp_model_classification(p_model, [115.34, 111.22], 4)#     # after_load = predict_mlp_model_classification(p_model2, [1, 1], 4)##     # print("Before:", before_save)#     # print("After:", after_load)##     # destroy_mlp_prediction(before_save)#     # destroy_mlp_prediction(after_load)#     destroy_linear_model(p_model)#     destroy_linear_model(p_model2)# except Exception as e:#     print("Erreur:", e)def create_some_linear_models():    for i in range(15):        id = np.random.randint(1, 50)        filename = "models/lin/model" + str(id) + ".txt"        p_model = create_linear_model(id)        save_linear_model(p_model, id, filename)def create_some_mlp_models():    for i in range(15):        id = np.random.randint(1, 50)        filename = "models/mlp/model" + str(id) + ".txt"        layers = [np.random.randint(2, 7) for _ in range(np.random.randint(3, 6))]        # print(layers)        p_model, _ = create_mlp_model(layers)        save_mlp_model(p_model, filename)# create_some_mlp_models()# p_model2 = load_mlp_model("models/mlp/model3.txt")## save_mlp_model(p_model2, "models/mlp/model3bis.txt")# print("no soucis")#p_model, last_layer = create_mlp_model([3, 3, 2])arr = predict_mlp_model_classification(p_model, [1, 1], last_layer)print("1 : ", arr)arr = predict_mlp_model_classification(p_model, [1, 1], last_layer)print("1-2 : ", arr)arr = predict_mlp_model_classification(p_model, [1, 1], last_layer)print("1-3 : ", arr)save_mlp_model(p_model, "models/mlp/test.txt")destroy_mlp_model(p_model)p_model2 = load_mlp_model("models/mlp/test.txt")arr2 = predict_mlp_model_classification(p_model2, [1, 1], last_layer)print("2 : ", arr2)arr2 = predict_mlp_model_classification(p_model2, [1, 1], last_layer)print("2-2 : ", arr2)arr2 = predict_mlp_model_classification(p_model2, [1, 1], last_layer)print("2-3 : ", arr2)save_mlp_model(p_model2, "models/mlp/reda_test.txt")destroy_mlp_model(p_model2)p_model3 = load_mlp_model("models/mlp/reda_test.txt")arr3 = predict_mlp_model_classification(p_model3, [1, 1], last_layer)print("3 : ", arr2)save_mlp_model(p_model3, "models/mlp/reda_test_bis.txt")destroy_mlp_model(p_model3)"""import numpy as npimport osfrom PIL import Imageimport matplotlib.pyplot as pltIMG_SIZE = (8, 8)PATH = os.path.join("data_small/")TRAIN = os.path.join(PATH, "train")classes = os.listdir(TRAIN)def import_images_and_assign_labels(folder, label, X, Y):    for file in os.listdir(folder):        image_path = os.path.join(folder, file)        im = Image.open(image_path)        im = im.resize(IMG_SIZE)        im = im.convert("RGB")        im_arr = np.array(im)        im_arr = np.reshape(im_arr, (IMG_SIZE[0] * IMG_SIZE[1] * 3,))        X.append(im_arr)        Y.append(label)def import_dataset():    X_train, y_train, X_valid, y_valid = [], [], [], []    labels = np.identity(len(os.listdir(TRAIN)))    for set_type in ["train", "valid"]:        for cl, lab in zip(classes, labels):            if set_type == "train":                X_set, y_set = X_train, y_train            else:                X_set, y_set = X_valid, y_valid            import_images_and_assign_labels(                os.path.join(PATH, set_type, cl),                lab,                X_set,                y_set            )    return (np.array(X_train) / 255.0, np.array(y_train)), \           (np.array(X_valid) / 255.0, np.array(y_valid))(X_train, y_train), (X_valid, y_valid) = import_dataset()local, _ = create_mlp_model([192, 16, 8])for i in range(1):    print(predict_mlp_model_classification(local, X_train[i], 8))#print(predict_mlp_model_classification(local, X_train[37], 8))destroy_mlp_model(local)input_dim = [len(X_train[0]), 8]p_model, len_output_layer = create_mlp_model(input_dim)for x, y in zip(X_train[:10], y_train[:10]):    arr = predict_mlp_model_classification(p_model, x, len_output_layer)    print(np.argmax(arr), np.argmax(y))train_classification_stochastic_gradient_backpropagation_mlp_model(p_model, X_train, y_train.flatten(),                                                                   epochs=10)destroy_mlp_model(p_model)exit()print("start")def accuracy(model, len_output_layer):    true_pred = 0    preds_labels = []    for x in X_train:        preds_labels.append(np.argmax(predict_mlp_model_classification(model, x, len_output_layer)))    true_labels = []    for y in y_train:        true_labels.append(np.argmax(y))    for i in range(len(preds_labels)):        if preds_labels[i] == true_labels[i]:            true_pred += 1    total = len(preds_labels)    print(true_pred / total)accuracy(p_model, len_output_layer)picture_test = np.random.randint(0, len(X_valid) - 1)test_before = predict_mlp_model_classification(p_model, X_valid[picture_test], len_output_layer)print("Before training:", test_before)print(picture_test)# showImg(X_valid[picture_test], y_valid[picture_test], test_before)random_idx_train = []random_idx_valid = []for _ in range(10):    rdm = np.random.randint(0, len(X_train) - 1)    print(rdm)    random_idx_train.append(rdm)    rdm = np.random.randint(0, len(X_valid) - 1)    print(rdm)    random_idx_valid.append(rdm)# random_idx_train = [np.random.randint(0, len(X_train) - 1) for _ in range(50)]# random_idx_valid = [np.random.randint(0, len(X_valid) - 1) for _ in range(50)]# nb_rows_valid = X_valid.shape[0]# random_idx_valid = np.random.choice(nb_rows_valid, 50, replace=False)accuracy(p_model, len_output_layer)# accuracy(X_valid[random_idx_valid, :], y_valid[random_idx_valid, :], p_model, len_output_layer)train_classification_stochastic_gradient_backpropagation_mlp_model(p_model, X_train, y_train.flatten(),                                                                   epochs=4)# test_after = predict_mlp_model_classification(p_model, X_valid[picture_test], len_output_layer)# print("After training:", test_after)# print("Class index : ", np.argmax(test_after))# print("Class expected :", np.argmax(y_train[picture_test]))# showImg(X_valid[picture_test], y_valid[picture_test], test_after)print("---- After training ----")accuracy(p_model, len_output_layer)# accuracy(p_model, len_output_layer)destroy_mlp_model(p_model)